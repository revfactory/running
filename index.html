<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Îã¨Î¶¨Í∏∞ ÎåÄÌöå</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #87CEEB; font-family: 'Arial', sans-serif; }
canvas { display: block; }

#ui {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 10;
}

#scoreboard {
  position: absolute;
  top: 16px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 8px;
  opacity: 0;
  transition: opacity 0.5s;
}

.rank-card {
  background: rgba(0,0,0,0.7);
  border-radius: 10px;
  padding: 8px 14px;
  min-width: 80px;
  text-align: center;
  backdrop-filter: blur(10px);
  border: 2px solid rgba(255,255,255,0.1);
  transition: all 0.3s;
  position: relative;
  overflow: hidden;
}

.rank-card.first {
  transform: scale(1.12);
  border-color: #FFD700;
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
}

.rank-card.first::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(45deg, transparent 40%, rgba(255,215,0,0.1) 50%, transparent 60%);
  animation: shimmer 2s infinite;
}

@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.rank-card .rank-num {
  font-size: 10px;
  color: rgba(255,255,255,0.4);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.rank-card .name {
  font-size: 16px;
  font-weight: bold;
  margin: 2px 0;
}

.rank-card .speed-bar {
  height: 3px;
  background: rgba(255,255,255,0.1);
  border-radius: 2px;
  margin-top: 4px;
  overflow: hidden;
}

.rank-card .speed-fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.3s;
  width: 50%;
}

#commentary {
  position: absolute;
  bottom: 80px;
  left: 50%;
  transform: translateX(-50%);
  color: #fff;
  font-size: 22px;
  font-weight: bold;
  text-align: center;
  opacity: 0;
  transition: opacity 0.3s;
  text-shadow: 0 0 10px rgba(0,0,0,0.8), 0 0 30px rgba(255,50,50,0.3);
  white-space: nowrap;
  pointer-events: none;
}

#commentary.active {
  opacity: 1;
  animation: commentPop 0.3s ease-out;
}

@keyframes commentPop {
  0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
  60% { transform: translateX(-50%) scale(1.1); }
  100% { transform: translateX(-50%) scale(1); opacity: 1; }
}

#overtake-flash {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 5;
  opacity: 0;
  transition: opacity 0.1s;
}

#start-screen {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 100;
}

#start-screen h1 {
  color: #fff;
  font-size: 56px;
  text-shadow: 0 0 40px rgba(255,100,100,0.5);
  margin-bottom: 8px;
  letter-spacing: 4px;
}

#start-screen .subtitle {
  color: rgba(255,255,255,0.5);
  font-size: 14px;
  letter-spacing: 6px;
  text-transform: uppercase;
  margin-bottom: 32px;
}

#start-screen .chars {
  display: flex;
  gap: 16px;
  margin-bottom: 40px;
}

.char-preview {
  text-align: center;
  background: rgba(255,255,255,0.05);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 12px;
  padding: 16px 20px;
  transition: transform 0.2s;
}

.char-preview:hover {
  transform: scale(1.05);
  border-color: rgba(255,255,255,0.3);
}

.char-preview .dot {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  margin: 0 auto 8px;
  box-shadow: 0 0 15px currentColor;
}

.char-preview .cname {
  color: #fff;
  font-weight: bold;
  font-size: 18px;
}

.char-preview .gender {
  color: rgba(255,255,255,0.4);
  font-size: 12px;
}

#start-btn {
  background: linear-gradient(135deg, #e74c3c, #c0392b);
  border: none;
  padding: 18px 56px;
  font-size: 24px;
  font-weight: bold;
  border-radius: 50px;
  cursor: pointer;
  color: #fff;
  box-shadow: 0 6px 30px rgba(231,76,60,0.4);
  transition: transform 0.2s, box-shadow 0.2s;
  pointer-events: auto;
  letter-spacing: 4px;
  text-transform: uppercase;
}

#start-btn:hover {
  transform: scale(1.08);
  box-shadow: 0 8px 40px rgba(231,76,60,0.6);
}

#countdown {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 99;
  pointer-events: none;
}

#countdown .num {
  font-size: 150px;
  font-weight: 900;
  color: #fff;
  text-shadow: 0 0 60px rgba(255,50,50,0.8);
  animation: countPulse 0.8s ease-out;
}

@keyframes countPulse {
  0% { transform: scale(2); opacity: 0; }
  30% { opacity: 1; }
  100% { transform: scale(1); opacity: 0.8; }
}

#lap-counter {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  color: #fff;
  font-size: 14px;
  background: rgba(0,0,0,0.6);
  padding: 8px 20px;
  border-radius: 20px;
  backdrop-filter: blur(5px);
}

#tension-bar {
  position: absolute;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  width: 200px;
  text-align: center;
  opacity: 0;
  transition: opacity 0.5s;
}

#tension-bar .label {
  font-size: 10px;
  color: rgba(255,255,255,0.5);
  letter-spacing: 2px;
  text-transform: uppercase;
  margin-bottom: 4px;
}

#tension-bar .bar {
  height: 4px;
  background: rgba(255,255,255,0.1);
  border-radius: 2px;
  overflow: hidden;
}

#tension-bar .fill {
  height: 100%;
  border-radius: 2px;
  transition: width 0.5s, background 0.5s;
  background: #4ade80;
}

#camera-hint {
  position: absolute;
  bottom: 50px;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(255,255,255,0.3);
  font-size: 11px;
  opacity: 1;
  transition: opacity 2s;
}

#vignette {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  pointer-events: none;
  z-index: 4;
  background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.4) 100%);
}
</style>
</head>
<body>

<div id="start-screen">
  <h1>RACE!</h1>
  <div class="subtitle">ÌÖîÎ†àÌÜ†ÎπÑ ÎèôÏÇ∞ Îã¨Î¶¨Í∏∞ ÎåÄÌöå</div>
  <div class="chars">
    <div class="char-preview">
      <div class="dot" style="background: #FF69B4; color: #FF69B4;"></div>
      <div class="cname">ÎÇòÎÇò</div>
      <div class="gender">‚ôÄ</div>
    </div>
    <div class="char-preview">
      <div class="dot" style="background: #FFD700; color: #FFD700;"></div>
      <div class="cname">Ï°∞ÏïÑ</div>
      <div class="gender">‚ôÄ</div>
    </div>
    <div class="char-preview">
      <div class="dot" style="background: #FF6347; color: #FF6347;"></div>
      <div class="cname">ÎùºÎùº</div>
      <div class="gender">‚ôÄ</div>
    </div>
    <div class="char-preview">
      <div class="dot" style="background: #4FC3F7; color: #4FC3F7;"></div>
      <div class="cname">Î°úÎ°ú</div>
      <div class="gender">‚ôÇ</div>
    </div>
  </div>
  <button id="start-btn">START</button>
</div>

<div id="countdown"><div class="num"></div></div>

<div id="vignette"></div>
<div id="overtake-flash"></div>

<div id="ui">
  <div id="scoreboard">
    <div class="rank-card" id="rank-0">
      <div class="rank-num">1st</div>
      <div class="name">-</div>
      <div class="speed-bar"><div class="speed-fill"></div></div>
    </div>
    <div class="rank-card" id="rank-1">
      <div class="rank-num">2nd</div>
      <div class="name">-</div>
      <div class="speed-bar"><div class="speed-fill"></div></div>
    </div>
    <div class="rank-card" id="rank-2">
      <div class="rank-num">3rd</div>
      <div class="name">-</div>
      <div class="speed-bar"><div class="speed-fill"></div></div>
    </div>
    <div class="rank-card" id="rank-3">
      <div class="rank-num">4th</div>
      <div class="name">-</div>
      <div class="speed-bar"><div class="speed-fill"></div></div>
    </div>
  </div>

  <div id="tension-bar">
    <div class="label">Ï†ëÏ†ÑÎèÑ</div>
    <div class="bar"><div class="fill"></div></div>
  </div>

  <div id="commentary"></div>
  <div id="lap-counter"></div>
  <div id="camera-hint">ÎßàÏö∞Ïä§ ÎìúÎûòÍ∑∏: Ïπ¥Î©îÎùº ÌöåÏ†Ñ | Ïä§ÌÅ¨Î°§: Ï§å</div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';

// ‚îÄ‚îÄ‚îÄ Character Data ‚îÄ‚îÄ‚îÄ
const CHARACTERS = [
  { name: 'ÎÇòÎÇò', color: 0xFF69B4, skinColor: 0xFFDBC4, gender: 'F', hairColor: 0x2a1a0a },
  { name: 'Ï°∞ÏïÑ', color: 0xFFD700, skinColor: 0xF5D0A9, gender: 'F', hairColor: 0x5c3317 },
  { name: 'ÎùºÎùº', color: 0xFF6347, skinColor: 0xFFE0BD, gender: 'F', hairColor: 0x1a1a2e },
  { name: 'Î°úÎ°ú', color: 0x4FC3F7, skinColor: 0xE8C39E, gender: 'M', hairColor: 0x1a1a1a },
];

// ‚îÄ‚îÄ‚îÄ Track Config ‚îÄ‚îÄ‚îÄ
const TRACK_RADIUS = 40;
const TRACK_WIDTH = 10;
const LANE_COUNT = 4;
const LANE_WIDTH = TRACK_WIDTH / LANE_COUNT;

// ‚îÄ‚îÄ‚îÄ State ‚îÄ‚îÄ‚îÄ
let running = false;
let time = 0;
let runners = [];
let cameraAngle = 0;
let cameraPitch = 0.35;
let cameraDist = 18;
let targetCameraDist = 18;
let isDragging = false;
let lastMouse = { x: 0, y: 0 };
let prevRankOrder = [];
let commentTimer = null;
let screenShake = 0;
let cameraMode = 'chase'; // chase, dramatic, overhead
let cameraModeTimer = 0;
let tensionLevel = 0;
let lastOvertakeTime = -10;

// ‚îÄ‚îÄ‚îÄ Three.js Setup ‚îÄ‚îÄ‚îÄ
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.FogExp2(0x87CEEB, 0.004);

const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// ‚îÄ‚îÄ‚îÄ Lighting ‚îÄ‚îÄ‚îÄ
const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xFFF8E1, 1.4);
sunLight.position.set(60, 80, 40);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
sunLight.shadow.camera.left = -80;
sunLight.shadow.camera.right = 80;
sunLight.shadow.camera.top = 80;
sunLight.shadow.camera.bottom = -80;
scene.add(sunLight);

const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x56ab2f, 0.3);
scene.add(hemiLight);

// ‚îÄ‚îÄ‚îÄ Sun ‚îÄ‚îÄ‚îÄ
const sun = new THREE.Mesh(
  new THREE.SphereGeometry(8, 16, 16),
  new THREE.MeshBasicMaterial({ color: 0xFFFF44 })
);
sun.position.set(100, 120, -80);
scene.add(sun);

const rayMat = new THREE.MeshBasicMaterial({ color: 0xFFFF88, transparent: true, opacity: 0.3 });
for (let i = 0; i < 8; i++) {
  const ray = new THREE.Mesh(new THREE.BoxGeometry(1, 14, 1), rayMat);
  ray.position.copy(sun.position);
  ray.rotation.z = (i / 8) * Math.PI;
  scene.add(ray);
}

// ‚îÄ‚îÄ‚îÄ Ground ‚îÄ‚îÄ‚îÄ
const groundSize = 300;
const groundSeg = 80;
const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize, groundSeg, groundSeg);
groundGeo.rotateX(-Math.PI / 2);

const posAttr = groundGeo.attributes.position;
for (let i = 0; i < posAttr.count; i++) {
  const x = posAttr.getX(i);
  const z = posAttr.getZ(i);
  const d = Math.sqrt(x * x + z * z);
  if (d < TRACK_RADIUS + TRACK_WIDTH + 3) {
    posAttr.setY(i, 0);
  } else {
    const h = Math.sin(x * 0.04) * 4 + Math.cos(z * 0.05) * 3 +
              Math.sin(x * 0.02 + z * 0.03) * 6 + Math.cos(x * 0.06 - z * 0.04) * 2;
    posAttr.setY(i, Math.max(0, h));
  }
}
groundGeo.computeVertexNormals();
const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color: 0x7CCD3B, roughness: 0.9 }));
ground.receiveShadow = true;
scene.add(ground);

// ‚îÄ‚îÄ‚îÄ Track ‚îÄ‚îÄ‚îÄ
const outerR = TRACK_RADIUS + TRACK_WIDTH / 2;
const innerR = TRACK_RADIUS - TRACK_WIDTH / 2;

const trackShape = new THREE.Shape();
for (let i = 0; i <= 64; i++) {
  const a = (i / 64) * Math.PI * 2;
  if (i === 0) trackShape.moveTo(Math.cos(a) * outerR, Math.sin(a) * outerR);
  else trackShape.lineTo(Math.cos(a) * outerR, Math.sin(a) * outerR);
}
const holePath = new THREE.Path();
for (let i = 0; i <= 64; i++) {
  const a = (i / 64) * Math.PI * 2;
  if (i === 0) holePath.moveTo(Math.cos(a) * innerR, Math.sin(a) * innerR);
  else holePath.lineTo(Math.cos(a) * innerR, Math.sin(a) * innerR);
}
trackShape.holes.push(holePath);

const trackGeo = new THREE.ShapeGeometry(trackShape);
trackGeo.rotateX(-Math.PI / 2);
const track = new THREE.Mesh(trackGeo, new THREE.MeshStandardMaterial({ color: 0xD2691E, roughness: 0.95 }));
track.position.y = 0.05;
track.receiveShadow = true;
scene.add(track);

// Lane lines
for (let lane = 0; lane <= LANE_COUNT; lane++) {
  const r = innerR + lane * LANE_WIDTH;
  const pts = [];
  for (let i = 0; i <= 64; i++) {
    const a = (i / 64) * Math.PI * 2;
    pts.push(new THREE.Vector3(Math.cos(a) * r, 0.08, Math.sin(a) * r));
  }
  scene.add(new THREE.Line(
    new THREE.BufferGeometry().setFromPoints(pts),
    new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: lane === 0 || lane === LANE_COUNT ? 0.8 : 0.35 })
  ));
}

// ‚îÄ‚îÄ‚îÄ Flowers ‚îÄ‚îÄ‚îÄ
function createFlower(x, z, color) {
  const g = new THREE.Group();
  g.add((() => {
    const s = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.6, 4), new THREE.MeshStandardMaterial({ color: 0x2d8a2d }));
    s.position.y = 0.3; return s;
  })());
  for (let i = 0; i < 5; i++) {
    const p = new THREE.Mesh(new THREE.SphereGeometry(0.15, 6, 6), new THREE.MeshStandardMaterial({ color }));
    const a = (i / 5) * Math.PI * 2;
    p.position.set(Math.cos(a) * 0.15, 0.65, Math.sin(a) * 0.15);
    p.scale.y = 0.6;
    g.add(p);
  }
  const c = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), new THREE.MeshStandardMaterial({ color: 0xFFFF00 }));
  c.position.y = 0.65;
  g.add(c);
  g.position.set(x, 0, z);
  g.scale.setScalar(0.8 + Math.random() * 0.6);
  return g;
}

const flowerColors = [0xFF69B4, 0xFF6347, 0xFFD700, 0xFF00FF, 0xFF4500, 0xDA70D6];
for (let i = 0; i < 200; i++) {
  const a = Math.random() * Math.PI * 2, d = outerR + 3 + Math.random() * 80;
  scene.add(createFlower(Math.cos(a) * d, Math.sin(a) * d, flowerColors[Math.floor(Math.random() * flowerColors.length)]));
}
for (let i = 0; i < 60; i++) {
  const a = Math.random() * Math.PI * 2, d = Math.random() * (innerR - 4);
  scene.add(createFlower(Math.cos(a) * d, Math.sin(a) * d, flowerColors[Math.floor(Math.random() * flowerColors.length)]));
}

// ‚îÄ‚îÄ‚îÄ Bunnies ‚îÄ‚îÄ‚îÄ
const bunnies = [];
function createBunny(x, z) {
  const g = new THREE.Group();
  const m = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.8 });
  const body = new THREE.Mesh(new THREE.SphereGeometry(0.4, 8, 8), m);
  body.position.y = 0.4; body.scale.set(1, 0.8, 0.8); g.add(body);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.25, 8, 8), m);
  head.position.set(0, 0.75, 0.15); g.add(head);
  for (let s = -1; s <= 1; s += 2) {
    const ear = new THREE.Mesh(new THREE.CapsuleGeometry(0.06, 0.3, 4, 4), m);
    ear.position.set(s * 0.12, 1.1, 0.15); ear.rotation.z = s * 0.2; g.add(ear);
    const eye = new THREE.Mesh(new THREE.SphereGeometry(0.04, 6, 6), new THREE.MeshBasicMaterial({ color: 0x111111 }));
    eye.position.set(s * 0.1, 0.8, 0.35); g.add(eye);
  }
  const tail = new THREE.Mesh(new THREE.SphereGeometry(0.12, 6, 6), m);
  tail.position.set(0, 0.4, -0.35); g.add(tail);
  g.position.set(x, 0, z);
  g.userData = { baseX: x, baseZ: z, hopPhase: Math.random() * Math.PI * 2 };
  return g;
}
for (let i = 0; i < 10; i++) {
  const a = Math.random() * Math.PI * 2, d = innerR * Math.random() * 0.7;
  const b = createBunny(Math.cos(a) * d, Math.sin(a) * d);
  scene.add(b); bunnies.push(b);
}

// ‚îÄ‚îÄ‚îÄ Trees ‚îÄ‚îÄ‚îÄ
for (let i = 0; i < 25; i++) {
  const a = Math.random() * Math.PI * 2, d = outerR + 10 + Math.random() * 70;
  const s = 1.5 + Math.random() * 2;
  const g = new THREE.Group();
  const trunk = new THREE.Mesh(new THREE.CylinderGeometry(s * 0.15, s * 0.2, s * 1.5, 6), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
  trunk.position.y = s * 0.75; trunk.castShadow = true; g.add(trunk);
  const leaves = new THREE.Mesh(new THREE.SphereGeometry(s * 0.8, 8, 8), new THREE.MeshStandardMaterial({ color: 0x2ECC40, roughness: 0.8 }));
  leaves.position.y = s * 1.8; leaves.castShadow = true; g.add(leaves);
  g.position.set(Math.cos(a) * d, 0, Math.sin(a) * d);
  scene.add(g);
}

// ‚îÄ‚îÄ‚îÄ Butterflies ‚îÄ‚îÄ‚îÄ
const butterflies = [];
for (let i = 0; i < 15; i++) {
  const g = new THREE.Group();
  const col = [0xFF69B4, 0xFFD700, 0x87CEEB, 0xFF6347, 0xDA70D6][Math.floor(Math.random() * 5)];
  const wm = new THREE.MeshBasicMaterial({ color: col, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
  for (let s = -1; s <= 1; s += 2) {
    const w = new THREE.Mesh(new THREE.CircleGeometry(0.3, 6), wm);
    w.position.x = s * 0.15; w.rotation.y = s * 0.5; w.userData.side = s; g.add(w);
  }
  g.add(new THREE.Mesh(new THREE.CapsuleGeometry(0.03, 0.2, 3, 3), new THREE.MeshBasicMaterial({ color: 0x333333 })));
  const a = Math.random() * Math.PI * 2, d = Math.random() * 80;
  g.position.set(Math.cos(a) * d, 2 + Math.random() * 4, Math.sin(a) * d);
  g.userData = { phase: Math.random() * Math.PI * 2, centerX: g.position.x, centerZ: g.position.z, radius: 2 + Math.random() * 5 };
  scene.add(g); butterflies.push(g);
}

// ‚îÄ‚îÄ‚îÄ Rainbow ‚îÄ‚îÄ‚îÄ
[0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x9400D3].forEach((color, i) => {
  const r = 60 + i * 1.5;
  const curve = new THREE.EllipseCurve(0, 0, r, r, 0, Math.PI, false, 0);
  const pts3D = curve.getPoints(50).map(p => new THREE.Vector3(p.x, p.y, -100));
  scene.add(new THREE.Line(
    new THREE.BufferGeometry().setFromPoints(pts3D),
    new THREE.LineBasicMaterial({ color, transparent: true, opacity: 0.3 })
  ));
});

// ‚îÄ‚îÄ‚îÄ Dust Particle System ‚îÄ‚îÄ‚îÄ
const dustCount = 300;
const dustGeo = new THREE.BufferGeometry();
const dustPos = new Float32Array(dustCount * 3);
const dustVel = new Float32Array(dustCount * 3);
const dustLife = new Float32Array(dustCount);
for (let i = 0; i < dustCount; i++) {
  dustPos[i * 3] = dustPos[i * 3 + 1] = dustPos[i * 3 + 2] = 0;
  dustLife[i] = 0;
}
dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3));
const dustMat = new THREE.PointsMaterial({
  color: 0xD2B48C,
  size: 0.3,
  transparent: true,
  opacity: 0.6,
  sizeAttenuation: true,
  depthWrite: false,
});
const dustParticles = new THREE.Points(dustGeo, dustMat);
scene.add(dustParticles);
let dustIndex = 0;

function emitDust(x, y, z) {
  for (let j = 0; j < 3; j++) {
    const i = dustIndex % dustCount;
    dustPos[i * 3] = x + (Math.random() - 0.5) * 0.5;
    dustPos[i * 3 + 1] = y + Math.random() * 0.3;
    dustPos[i * 3 + 2] = z + (Math.random() - 0.5) * 0.5;
    dustVel[i * 3] = (Math.random() - 0.5) * 2;
    dustVel[i * 3 + 1] = 1 + Math.random() * 2;
    dustVel[i * 3 + 2] = (Math.random() - 0.5) * 2;
    dustLife[i] = 1;
    dustIndex++;
  }
}

function updateDust(delta) {
  for (let i = 0; i < dustCount; i++) {
    if (dustLife[i] <= 0) continue;
    dustLife[i] -= delta * 1.5;
    dustPos[i * 3] += dustVel[i * 3] * delta;
    dustPos[i * 3 + 1] += dustVel[i * 3 + 1] * delta;
    dustPos[i * 3 + 2] += dustVel[i * 3 + 2] * delta;
    dustVel[i * 3 + 1] -= 3 * delta; // gravity
    if (dustLife[i] <= 0) {
      dustPos[i * 3 + 1] = -100; // hide
    }
  }
  dustGeo.attributes.position.needsUpdate = true;
}

// ‚îÄ‚îÄ‚îÄ Speed Lines (3D) ‚îÄ‚îÄ‚îÄ
const speedLineGroup = new THREE.Group();
scene.add(speedLineGroup);
const speedLineMeshes = [];
for (let i = 0; i < 30; i++) {
  const m = new THREE.Mesh(
    new THREE.CylinderGeometry(0.015, 0.015, 3 + Math.random() * 5, 4),
    new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 })
  );
  m.userData.offset = Math.random() * Math.PI * 2;
  speedLineGroup.add(m);
  speedLineMeshes.push(m);
}

// ‚îÄ‚îÄ‚îÄ Overtake Burst Effect (3D) ‚îÄ‚îÄ‚îÄ
const burstParticles = [];
function createBurst(x, y, z, color) {
  for (let i = 0; i < 20; i++) {
    const m = new THREE.Mesh(
      new THREE.SphereGeometry(0.08, 4, 4),
      new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 1 })
    );
    m.position.set(x, y + 1, z);
    const angle = Math.random() * Math.PI * 2;
    const speed = 2 + Math.random() * 4;
    m.userData = {
      vx: Math.cos(angle) * speed,
      vy: 2 + Math.random() * 4,
      vz: Math.sin(angle) * speed,
      life: 1,
    };
    scene.add(m);
    burstParticles.push(m);
  }
}

function updateBursts(delta) {
  for (let i = burstParticles.length - 1; i >= 0; i--) {
    const p = burstParticles[i];
    p.userData.life -= delta * 2;
    p.position.x += p.userData.vx * delta;
    p.position.y += p.userData.vy * delta;
    p.position.z += p.userData.vz * delta;
    p.userData.vy -= 8 * delta;
    p.material.opacity = Math.max(0, p.userData.life);
    p.scale.setScalar(p.userData.life);
    if (p.userData.life <= 0) {
      scene.remove(p);
      burstParticles.splice(i, 1);
    }
  }
}

// ‚îÄ‚îÄ‚îÄ Create Character ‚îÄ‚îÄ‚îÄ
function createCharacter(data, laneIndex) {
  const group = new THREE.Group();
  const skinMat = new THREE.MeshStandardMaterial({ color: data.skinColor, roughness: 0.7 });
  const clothMat = new THREE.MeshStandardMaterial({ color: data.color, roughness: 0.6 });
  const hairMat = new THREE.MeshStandardMaterial({ color: data.hairColor, roughness: 0.8 });
  const shoeMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.5 });

  const torso = new THREE.Mesh(new THREE.CapsuleGeometry(0.35, 0.6, 6, 8), clothMat);
  torso.position.y = 1.3; torso.castShadow = true; group.add(torso);

  const head = new THREE.Mesh(new THREE.SphereGeometry(0.3, 10, 10), skinMat);
  head.position.y = 2.0; head.castShadow = true; group.add(head);

  if (data.gender === 'F') {
    const hair = new THREE.Mesh(new THREE.SphereGeometry(0.32, 10, 10, 0, Math.PI * 2, 0, Math.PI * 0.6), hairMat);
    hair.position.y = 2.05; group.add(hair);
    const ponytail = new THREE.Mesh(new THREE.CapsuleGeometry(0.08, 0.3, 4, 4), hairMat);
    ponytail.position.set(0, 2.0, -0.25); ponytail.rotation.x = 0.5;
    group.add(ponytail);
    group.userData.ponytail = ponytail;
  } else {
    const hair = new THREE.Mesh(new THREE.SphereGeometry(0.31, 10, 10, 0, Math.PI * 2, 0, Math.PI * 0.45), hairMat);
    hair.position.y = 2.05; group.add(hair);
  }

  for (let side = -1; side <= 1; side += 2) {
    const ew = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 6), new THREE.MeshBasicMaterial({ color: 0xffffff }));
    ew.position.set(side * 0.12, 2.04, 0.24); group.add(ew);
    const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.035, 6, 6), new THREE.MeshBasicMaterial({ color: 0x111111 }));
    pupil.position.set(side * 0.12, 2.04, 0.28); group.add(pupil);
    const cheek = new THREE.Mesh(new THREE.CircleGeometry(0.05, 8), new THREE.MeshBasicMaterial({ color: 0xFFAAAA, transparent: true, opacity: 0.4 }));
    cheek.position.set(side * 0.2, 1.95, 0.27); group.add(cheek);
  }

  // Determined expression (furrowed brows)
  for (let side = -1; side <= 1; side += 2) {
    const brow = new THREE.Mesh(
      new THREE.BoxGeometry(0.08, 0.02, 0.01),
      new THREE.MeshBasicMaterial({ color: data.hairColor })
    );
    brow.position.set(side * 0.12, 2.12, 0.28);
    brow.rotation.z = side * -0.2;
    group.add(brow);
  }

  const leftArmPivot = new THREE.Group();
  leftArmPivot.position.set(-0.4, 1.55, 0);
  const la = new THREE.Mesh(new THREE.CapsuleGeometry(0.1, 0.45, 4, 6), skinMat);
  la.position.y = -0.28; la.castShadow = true; leftArmPivot.add(la);
  group.add(leftArmPivot);

  const rightArmPivot = new THREE.Group();
  rightArmPivot.position.set(0.4, 1.55, 0);
  const ra = new THREE.Mesh(new THREE.CapsuleGeometry(0.1, 0.45, 4, 6), skinMat);
  ra.position.y = -0.28; ra.castShadow = true; rightArmPivot.add(ra);
  group.add(rightArmPivot);

  const leftLegPivot = new THREE.Group();
  leftLegPivot.position.set(-0.15, 0.95, 0);
  const ll = new THREE.Mesh(new THREE.CapsuleGeometry(0.12, 0.45, 4, 6), clothMat);
  ll.position.y = -0.3; ll.castShadow = true; leftLegPivot.add(ll);
  const ls = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.1, 0.25), shoeMat);
  ls.position.set(0, -0.58, 0.05); leftLegPivot.add(ls);
  group.add(leftLegPivot);

  const rightLegPivot = new THREE.Group();
  rightLegPivot.position.set(0.15, 0.95, 0);
  const rl = new THREE.Mesh(new THREE.CapsuleGeometry(0.12, 0.45, 4, 6), clothMat);
  rl.position.y = -0.3; rl.castShadow = true; rightLegPivot.add(rl);
  const rs = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.1, 0.25), shoeMat);
  rs.position.set(0, -0.58, 0.05); rightLegPivot.add(rs);
  group.add(rightLegPivot);

  // Name tag
  const canvas = document.createElement('canvas');
  canvas.width = 128; canvas.height = 48;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.beginPath(); ctx.roundRect(4, 4, 120, 40, 12); ctx.fill();
  ctx.strokeStyle = '#' + data.color.toString(16).padStart(6, '0');
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.roundRect(4, 4, 120, 40, 12); ctx.stroke();
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 24px Arial';
  ctx.textAlign = 'center';
  ctx.fillText(data.name, 64, 32);

  const nameSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true }));
  nameSprite.position.y = 2.6;
  nameSprite.scale.set(1.2, 0.45, 1);
  group.add(nameSprite);

  // Aura effect (visible during surge)
  const auraGeo = new THREE.RingGeometry(0.5, 0.8, 16);
  const auraMat = new THREE.MeshBasicMaterial({ color: data.color, transparent: true, opacity: 0, side: THREE.DoubleSide });
  const aura = new THREE.Mesh(auraGeo, auraMat);
  aura.rotation.x = -Math.PI / 2;
  aura.position.y = 0.1;
  group.add(aura);

  scene.add(group);

  const laneR = innerR + (laneIndex + 0.5) * LANE_WIDTH;
  return {
    group, data, leftArmPivot, rightArmPivot, leftLegPivot, rightLegPivot, torso, head, aura, auraMat,
    angle: 0,
    laneRadius: laneR,
    speed: 0,
    targetSpeed: 0,
    baseSpeed: 2.2 + Math.random() * 0.08,
    phase: Math.random() * Math.PI * 2,
    laps: 0,
    totalAngle: 0,
    animPhase: Math.random() * Math.PI * 2,
    rank: laneIndex,
    surging: false,
    variationFreq1: 0.3 + Math.random() * 0.4,
    variationFreq2: 0.8 + Math.random() * 0.6,
    variationFreq3: 0.12 + Math.random() * 0.15,
    variationAmp1: 0.1 + Math.random() * 0.08,
    variationAmp2: 0.05 + Math.random() * 0.04,
    variationAmp3: 0.15 + Math.random() * 0.1,
    variationOffset1: Math.random() * Math.PI * 2,
    variationOffset2: Math.random() * Math.PI * 2,
    variationOffset3: Math.random() * Math.PI * 2,
  };
}

for (let i = 0; i < CHARACTERS.length; i++) {
  runners.push(createCharacter(CHARACTERS[i], i));
}
prevRankOrder = runners.map(r => r.data.name);

// ‚îÄ‚îÄ‚îÄ Commentary System ‚îÄ‚îÄ‚îÄ
const commentaryEl = document.getElementById('commentary');
const overtakeFlash = document.getElementById('overtake-flash');

function showCommentary(text, duration = 2500) {
  commentaryEl.textContent = text;
  commentaryEl.classList.add('active');
  clearTimeout(commentTimer);
  commentTimer = setTimeout(() => commentaryEl.classList.remove('active'), duration);
}

function flashScreen(color) {
  overtakeFlash.style.background = `radial-gradient(ellipse at center, ${color}33 0%, transparent 70%)`;
  overtakeFlash.style.opacity = '1';
  setTimeout(() => { overtakeFlash.style.opacity = '0'; }, 200);
}

const OVERTAKE_COMMENTS = [
  (a, b) => `${a}(Ïù¥)Í∞Ä ${b}ÏùÑ(Î•º) Ï∂îÏõî!!`,
  (a, b) => `${a} ÎßπÏ∂îÍ≤©! ${b} Î∞ÄÎ¶∞Îã§!`,
  (a, b) => `ÎåÄÏó≠Ï†Ñ!! ${a} ÏïûÏúºÎ°ú ÏπòÍ≥† ÎÇòÍ∞ÑÎã§!`,
  (a, b) => `${a} ÎÜÄÎùºÏö¥ Ïä§ÌçºÌä∏!!`,
  (a, b) => `${b} ÏúÑÍ∏∞! ${a} ÌååÏ£ΩÏßÄÏÑ∏!`,
];

const LEADER_COMMENTS = [
  (a) => `${a} ÏÑ†Îëê ÏßàÏ£º Ï§ë!`,
  (a) => `${a}, Î©àÏ∂ú Ï§Ñ Î™®Î•∏Îã§!`,
  (a) => `ÌòÑÏû¨ ${a} 1ÏúÑ!`,
];

const CLOSE_RACE_COMMENTS = [
  'Ï†ëÏ†Ñ! Ï†ëÏ†Ñ! Ï†ëÏ†Ñ!',
  'ÎàÑÍ∞Ä Ïù¥Í∏∏ÏßÄ Î™®Î•∏Îã§!!',
  'Ïà® ÎßâÌûàÎäî Ï†ëÏ†Ñ!!',
  'Ìïú Ïπò ÏïûÏùÑ Î™ª Î≥∏Îã§!',
  'Ìîº ÎßêÎ¶¨Îäî Î†àÏù¥Ïä§!',
];

// ‚îÄ‚îÄ‚îÄ Camera Controls ‚îÄ‚îÄ‚îÄ
renderer.domElement.addEventListener('mousedown', (e) => { isDragging = true; lastMouse.x = e.clientX; lastMouse.y = e.clientY; });
renderer.domElement.addEventListener('mousemove', (e) => {
  if (!isDragging) return;
  cameraAngle -= (e.clientX - lastMouse.x) * 0.005;
  cameraPitch = Math.max(0.08, Math.min(1.2, cameraPitch + (e.clientY - lastMouse.y) * 0.005));
  lastMouse.x = e.clientX; lastMouse.y = e.clientY;
});
renderer.domElement.addEventListener('mouseup', () => { isDragging = false; });
renderer.domElement.addEventListener('mouseleave', () => { isDragging = false; });
renderer.domElement.addEventListener('wheel', (e) => {
  targetCameraDist = Math.max(8, Math.min(60, targetCameraDist + e.deltaY * 0.03));
});

renderer.domElement.addEventListener('touchstart', (e) => { if (e.touches.length === 1) { isDragging = true; lastMouse.x = e.touches[0].clientX; lastMouse.y = e.touches[0].clientY; } });
renderer.domElement.addEventListener('touchmove', (e) => {
  if (!isDragging || e.touches.length !== 1) return;
  cameraAngle -= (e.touches[0].clientX - lastMouse.x) * 0.005;
  cameraPitch = Math.max(0.08, Math.min(1.2, cameraPitch + (e.touches[0].clientY - lastMouse.y) * 0.005));
  lastMouse.x = e.touches[0].clientX; lastMouse.y = e.touches[0].clientY;
  e.preventDefault();
}, { passive: false });
renderer.domElement.addEventListener('touchend', () => { isDragging = false; });

// ‚îÄ‚îÄ‚îÄ Start with Countdown ‚îÄ‚îÄ‚îÄ
document.getElementById('start-btn').addEventListener('click', () => {
  document.getElementById('start-screen').style.display = 'none';
  const countdownEl = document.getElementById('countdown');
  countdownEl.style.display = 'flex';

  let count = 3;
  const numEl = countdownEl.querySelector('.num');

  function tick() {
    if (count > 0) {
      numEl.textContent = count;
      numEl.style.animation = 'none';
      void numEl.offsetWidth;
      numEl.style.animation = 'countPulse 0.8s ease-out';
      count--;
      setTimeout(tick, 1000);
    } else {
      numEl.textContent = 'GO!';
      numEl.style.color = '#FFD700';
      numEl.style.animation = 'none';
      void numEl.offsetWidth;
      numEl.style.animation = 'countPulse 0.8s ease-out';
      setTimeout(() => {
        countdownEl.style.display = 'none';
        document.getElementById('scoreboard').style.opacity = '1';
        document.getElementById('tension-bar').style.opacity = '1';
        running = true;
        showCommentary('Î†àÏù¥Ïä§ ÏãúÏûë!! üèÅ', 2000);
      }, 600);
    }
  }
  tick();

  setTimeout(() => { document.getElementById('camera-hint').style.opacity = '0'; }, 6000);
});

// ‚îÄ‚îÄ‚îÄ Resize ‚îÄ‚îÄ‚îÄ
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ‚îÄ‚îÄ‚îÄ UI Update ‚îÄ‚îÄ‚îÄ
const rankLabels = ['1st', '2nd', '3rd', '4th'];
const tensionFill = document.querySelector('#tension-bar .fill');
let lastCommentTime = 0;

function updateUI() {
  const sorted = [...runners].sort((a, b) => b.totalAngle - a.totalAngle);
  const newOrder = sorted.map(r => r.data.name);

  // Detect overtakes
  if (prevRankOrder.length && time > 2) {
    for (let i = 0; i < newOrder.length; i++) {
      const prev = prevRankOrder.indexOf(newOrder[i]);
      if (prev > i && i < 2 && time - lastOvertakeTime > 2) {
        // Someone moved up!
        const overtaker = newOrder[i];
        const overtaken = prevRankOrder[i];
        const comment = OVERTAKE_COMMENTS[Math.floor(Math.random() * OVERTAKE_COMMENTS.length)];
        showCommentary(comment(overtaker, overtaken), 2500);
        screenShake = 0.6;
        lastOvertakeTime = time;
        lastCommentTime = time;

        const runner = runners.find(r => r.data.name === overtaker);
        if (runner) {
          flashScreen('#' + runner.data.color.toString(16).padStart(6, '0'));
          createBurst(runner.group.position.x, runner.group.position.y, runner.group.position.z, runner.data.color);
        }

        // Dramatic zoom on overtake
        if (!isDragging) {
          targetCameraDist = 10;
          setTimeout(() => { targetCameraDist = 18; }, 2000);
        }
        break;
      }
    }
  }
  prevRankOrder = newOrder;

  // Update rank cards
  sorted.forEach((runner, idx) => {
    runner.rank = idx;
    const card = document.getElementById(`rank-${idx}`);
    const nameEl = card.querySelector('.name');
    const rankEl = card.querySelector('.rank-num');
    const speedFill = card.querySelector('.speed-fill');

    nameEl.textContent = runner.data.name;
    const colorHex = '#' + runner.data.color.toString(16).padStart(6, '0');
    nameEl.style.color = colorHex;
    rankEl.textContent = rankLabels[idx];

    const speedPct = Math.min(100, (runner.speed / 3) * 100);
    speedFill.style.width = speedPct + '%';
    speedFill.style.background = colorHex;

    card.classList.toggle('first', idx === 0);
    card.style.borderColor = idx === 0 ? '#FFD700' : 'rgba(255,255,255,0.1)';
  });

  // Tension level (how close the race is)
  const maxAngle = sorted[0].totalAngle;
  const minAngle = sorted[sorted.length - 1].totalAngle;
  const spread = maxAngle - minAngle;
  tensionLevel = Math.max(0, Math.min(1, 1 - spread * 5));

  tensionFill.style.width = (tensionLevel * 100) + '%';
  if (tensionLevel > 0.8) tensionFill.style.background = '#ef4444';
  else if (tensionLevel > 0.5) tensionFill.style.background = '#f59e0b';
  else tensionFill.style.background = '#4ade80';

  // Periodic commentary
  if (time - lastCommentTime > 6) {
    if (tensionLevel > 0.7) {
      showCommentary(CLOSE_RACE_COMMENTS[Math.floor(Math.random() * CLOSE_RACE_COMMENTS.length)], 2000);
      lastCommentTime = time;
    } else if (Math.random() < 0.01) {
      const leader = sorted[0];
      const comment = LEADER_COMMENTS[Math.floor(Math.random() * LEADER_COMMENTS.length)];
      showCommentary(comment(leader.data.name), 2000);
      lastCommentTime = time;
    }
  }

  // Lap counter
  const leader = sorted[0];
  document.getElementById('lap-counter').textContent =
    `${leader.data.name} ÏÑ†Îëê | ${leader.laps} Î∞îÌÄ¥`;
}

// ‚îÄ‚îÄ‚îÄ Animation Loop ‚îÄ‚îÄ‚îÄ
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const delta = Math.min(clock.getDelta(), 0.05);
  time += delta;

  // Smooth camera distance
  cameraDist += (targetCameraDist - cameraDist) * delta * 3;

  if (!running) {
    runners.forEach((runner, i) => {
      const a = (i / runners.length) * 0.1 - 0.05;
      runner.group.position.set(Math.cos(a) * runner.laneRadius, 0, Math.sin(a) * runner.laneRadius);
      runner.group.rotation.y = -a;
      runner.torso.scale.y = 1 + Math.sin(time * 2 + i) * 0.02;
    });

    if (!isDragging) cameraAngle = time * 0.15;
    camera.position.set(Math.cos(cameraAngle) * 30, 12, Math.sin(cameraAngle) * 30);
    camera.lookAt(0, 1.5, 0);
    renderer.render(scene, camera);
    return;
  }

  // ‚îÄ‚îÄ‚îÄ Camera mode switching ‚îÄ‚îÄ‚îÄ
  cameraModeTimer += delta;
  if (cameraModeTimer > 8 && !isDragging) {
    cameraModeTimer = 0;
    const modes = ['chase', 'chase', 'chase', 'side', 'dramatic'];
    cameraMode = modes[Math.floor(Math.random() * modes.length)];
    if (tensionLevel > 0.7) cameraMode = 'dramatic';
  }

  // ‚îÄ‚îÄ‚îÄ Update Runners ‚îÄ‚îÄ‚îÄ
  runners.forEach((runner) => {
    const v1 = Math.sin(time * runner.variationFreq1 + runner.variationOffset1) * runner.variationAmp1;
    const v2 = Math.sin(time * runner.variationFreq2 + runner.variationOffset2) * runner.variationAmp2;
    const v3 = Math.sin(time * runner.variationFreq3 + runner.variationOffset3) * runner.variationAmp3;

    // Surge mechanic - more dramatic
    const surgeWave = Math.sin(time * 0.2 + runner.phase);
    const surge = surgeWave > 0.8 ? 0.2 * (surgeWave - 0.8) / 0.2 : 0;
    runner.surging = surge > 0.05;

    runner.targetSpeed = runner.baseSpeed + v1 + v2 + v3 + surge;

    // Rubber-banding
    const avgAngle = runners.reduce((s, r) => s + r.totalAngle, 0) / runners.length;
    const diff = runner.totalAngle - avgAngle;
    runner.targetSpeed -= diff * 0.2;

    // Drafting: slightly faster when right behind someone
    runners.forEach(other => {
      if (other === runner) return;
      const angleDiff = other.totalAngle - runner.totalAngle;
      if (angleDiff > 0 && angleDiff < 0.05) {
        runner.targetSpeed += 0.03; // slight draft boost
      }
    });

    runner.speed += (runner.targetSpeed - runner.speed) * delta * 4;
    const angularSpeed = runner.speed / runner.laneRadius;
    runner.angle += angularSpeed * delta;
    runner.totalAngle += angularSpeed * delta;
    runner.laps = Math.floor(runner.totalAngle / (Math.PI * 2));

    const x = Math.cos(runner.angle) * runner.laneRadius;
    const z = Math.sin(runner.angle) * runner.laneRadius;
    runner.group.position.set(x, 0, z);
    runner.group.rotation.y = -runner.angle;

    // ‚îÄ‚îÄ‚îÄ Running Animation (more intense) ‚îÄ‚îÄ‚îÄ
    const animSpeed = runner.speed * 4;
    runner.animPhase += delta * animSpeed;
    const p = runner.animPhase;

    // More aggressive arm swing
    runner.leftArmPivot.rotation.x = Math.sin(p) * 1.1;
    runner.rightArmPivot.rotation.x = -Math.sin(p) * 1.1;

    // More aggressive leg swing
    runner.leftLegPivot.rotation.x = -Math.sin(p) * 0.9;
    runner.rightLegPivot.rotation.x = Math.sin(p) * 0.9;

    // More forward lean
    runner.torso.rotation.x = 0.2 + (runner.surging ? 0.1 : 0);
    runner.torso.position.y = 1.3 + Math.abs(Math.sin(p * 2)) * 0.12;

    // Head bob
    runner.head.position.y = 2.0 + Math.abs(Math.sin(p * 2)) * 0.1;

    // Body bounce
    runner.group.position.y = Math.abs(Math.sin(p)) * 0.15;

    // Ponytail bounce for female characters
    if (runner.group.userData.ponytail) {
      runner.group.userData.ponytail.rotation.x = 0.5 + Math.sin(p * 2) * 0.3;
    }

    // Aura effect during surge
    runner.auraMat.opacity = runner.surging ? 0.3 + Math.sin(time * 10) * 0.15 : Math.max(0, runner.auraMat.opacity - delta * 3);
    runner.aura.rotation.z = time * 3;
    runner.aura.scale.setScalar(1 + Math.sin(time * 5) * 0.2);

    // Emit dust particles
    if (runner.speed > 1.5 && Math.random() < 0.3) {
      emitDust(x, 0.05, z);
    }
    if (runner.surging) {
      emitDust(x, 0.05, z);
      emitDust(x, 0.05, z);
    }
  });

  // ‚îÄ‚îÄ‚îÄ Update Effects ‚îÄ‚îÄ‚îÄ
  updateDust(delta);
  updateBursts(delta);
  screenShake *= (1 - delta * 5);

  // Speed lines
  const leader = [...runners].sort((a, b) => b.totalAngle - a.totalAngle)[0];
  const showLines = tensionLevel > 0.5 || leader.surging;
  speedLineMeshes.forEach((line, i) => {
    if (showLines) {
      line.visible = true;
      const offset = (time * 15 + i * 2.5 + line.userData.offset) % 30 - 15;
      line.position.set(
        leader.group.position.x + (Math.sin(i * 1.3) * 4),
        leader.group.position.y + 1.5 + Math.cos(i * 0.7) * 1.5,
        leader.group.position.z + (Math.cos(i * 1.7) * 4)
      );
      line.position.y += offset * 0.1;
      line.rotation.x = Math.PI / 2;
      line.rotation.z = -leader.angle;
      line.material.opacity = Math.max(0, 0.15 - Math.abs(offset) * 0.01) * (tensionLevel > 0.7 ? 2 : 1);
    } else {
      line.visible = false;
    }
  });

  // ‚îÄ‚îÄ‚îÄ Bunnies ‚îÄ‚îÄ‚îÄ
  bunnies.forEach(bunny => {
    bunny.userData.hopPhase += delta * 2;
    bunny.position.y = Math.abs(Math.sin(bunny.userData.hopPhase)) * 0.3;
    bunny.position.x = bunny.userData.baseX + Math.sin(time * 0.5 + bunny.userData.hopPhase) * 0.5;
    bunny.position.z = bunny.userData.baseZ + Math.cos(time * 0.3 + bunny.userData.hopPhase) * 0.5;
    bunny.rotation.y = Math.sin(time * 0.2 + bunny.userData.hopPhase * 0.5) * Math.PI;
  });

  // ‚îÄ‚îÄ‚îÄ Butterflies ‚îÄ‚îÄ‚îÄ
  butterflies.forEach(b => {
    b.userData.phase += delta * 2;
    const p = b.userData.phase;
    b.position.x = b.userData.centerX + Math.sin(p * 0.5) * b.userData.radius;
    b.position.z = b.userData.centerZ + Math.cos(p * 0.7) * b.userData.radius;
    b.position.y = 2 + Math.sin(p) * 1.5;
    b.children.forEach(child => {
      if (child.userData.side) child.rotation.y = child.userData.side * (0.3 + Math.sin(p * 8) * 0.7);
    });
  });

  // ‚îÄ‚îÄ‚îÄ Camera ‚îÄ‚îÄ‚îÄ
  const avgX = runners.reduce((s, r) => s + r.group.position.x, 0) / runners.length;
  const avgZ = runners.reduce((s, r) => s + r.group.position.z, 0) / runners.length;

  if (!isDragging) {
    if (cameraMode === 'chase') {
      const targetAngle = leader.angle + Math.PI * 0.55;
      cameraAngle += (targetAngle - cameraAngle) * delta * 1.5;
      cameraPitch += (0.25 - cameraPitch) * delta * 2;
    } else if (cameraMode === 'side') {
      const targetAngle = leader.angle + Math.PI / 2;
      cameraAngle += (targetAngle - cameraAngle) * delta * 2;
      cameraPitch += (0.15 - cameraPitch) * delta * 2;
      targetCameraDist = 12;
    } else if (cameraMode === 'dramatic') {
      const targetAngle = leader.angle + Math.PI * 0.3;
      cameraAngle += (targetAngle - cameraAngle) * delta * 2;
      cameraPitch += (0.12 - cameraPitch) * delta * 2;
      targetCameraDist = 10;
    }
  }

  // FOV changes with tension
  const targetFOV = 65 + tensionLevel * 15;
  camera.fov += (targetFOV - camera.fov) * delta * 2;
  camera.updateProjectionMatrix();

  const cx = avgX + Math.cos(cameraAngle) * cameraDist;
  const cz = avgZ + Math.sin(cameraAngle) * cameraDist;
  const cy = 1.5 + cameraDist * cameraPitch;

  const shakeX = screenShake * (Math.random() - 0.5) * 0.5;
  const shakeY = screenShake * (Math.random() - 0.5) * 0.3;

  camera.position.lerp(new THREE.Vector3(cx + shakeX, cy + shakeY, cz + shakeX), delta * 5);
  camera.lookAt(new THREE.Vector3(avgX, 1.2, avgZ));

  // ‚îÄ‚îÄ‚îÄ Dynamic lighting (pulses during tension) ‚îÄ‚îÄ‚îÄ
  if (tensionLevel > 0.7) {
    ambientLight.intensity = 0.5 + Math.sin(time * 4) * 0.05;
  } else {
    ambientLight.intensity = 0.5;
  }

  updateUI();
  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
